# 正規表現 (Regular Expression)
# パターンを指定して、文字列を効率よく検索/置換するためのミニ言語

# 例) 下記の文章からプログラミングっぽい文字列を抜き出す
text = <<TEXT
I love Ruby.
Python is a great language.
Java and JavaScript are different.
TEXT

text.scan(/[A-Z][A-Za-z]+/) #=> ["Ruby", "Python", "Java", "JavaScript"]

# 例) 郵便番号をハイフン区切りにする
text = <<TEXT
私の郵便番号は1234567です。
僕の住所は6770056 兵庫県西脇市板波町1234だよ。
TEXT

puts text.gsub(/(\d{3})(\d{4})/, '\1-\2')


text = <<-TEXT
名前：伊藤淳一
電話：03-1234-5678
住所：兵庫県西脇市板波町1-2-3
電話：03-1234-0000
電話：03-1234-9999
TEXT


\d は「半角数字1文字」を表す
{n,m} は「直前の文字が n 文字以上、m 文字以下」であることを表す
{n} は「直前の文字がちょうど n 文字」であることを表す
[]は1文字分を表す　[AB] は「AまたはBが1文字」であることを表す
[a-z] と [-az] ではハイフンの意味が異なる
正規表現の正確さと複雑さはトレードオフになることが多い

? は「直前の文字が1個、または無し」を表す
. は「任意の1文字」を表す(改行以外)
+ は「直前の文字が1個以上」を表す
* は「直前の文字が0個以上」を表す
( ) はマッチする部分をキャプチャ（捕捉）する
キャプチャした部分は置換するときに $1 や \1 で参照できる
\w は「英単語を構成する文字（半角英数字とアンダースコア）」を表す
[^AB] は「AでもなくBでもない任意の1文字」を表す
正規表現中の特別な文字は \ でエスケープする
( ) はキャプチャだけでなく、グループ化にも使われる
(ABC)? は「文字列 ABC があり、または無し」を表す
(?: ) はキャプチャ無しでグループ化する場合に使う
* と + は「貪欲」で最長マッチを返すため、使い方を誤ると思いがけない結果が返る
*? や +? にすると、最短マッチを返す
テキストエディタで重要なテキストを置換する際は、ひとつずつ確認しながら置換する

^ は行頭を表す
$ は行末を表す
\t はタブ文字を表す
\n は改行文字を表す
\s は空白文字（スペース、タブ文字、改行文字等）を表す
ABC|DEF は「文字列ABCまたは文字列DEF」のOR条件を表す
改行コードは環境によって異なる場合がある
^ は行頭の意味になったり、[^ ] で否定の文字クラスの意味になったりする

\b は単語の境界を表す
(?=abc) は「abcという文字列の直前の位置」を表す（先読み）
(?<=abc) 「abcという文字列の直後の位置」を表す（後読み）
(?!abc) は「abcという文字列以外の直前の位置」を表す（否定の先読み）
(?<!abc) 「abcという文字列以外の直後の位置」を表す（否定の後読み）
キャプチャした文字列は正規表現内でも \1 や \2 といった連番で参照できる（後方参照）
? や *、+ といった量指定子は ( ) の後ろに付けることもできる
| を使ったOR条件では、各条件内でもメタ文字が使える
書き方によっては、とんでもなく遅い正規表現ができあがることもある
メタ文字はバックスラッシュ（\）でエスケープする
[ ] 内ではメタ文字の種類や使われる位置によって各文字の働きが異なる
{n,} や {,n} はそれぞれ「直前の文字がn個以上」「n個以下」の意味になる
\W、\S、\D、\B はそれぞれ \w、\s、\d、\b の逆の意味になる
