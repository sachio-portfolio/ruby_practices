### 配列

# 異なるデータ型を格納することもできる
a = [1, 'apple', 2, 'orange', 3, 'melon']

# 配列の中に配列を含めることもできる
a = [[10, 20, 30],[40, 50, 60],[70, 80, 90]]

## 要素の変更、追加、削除

# 添え字を指定して値を代入すると要素を変更できる
a = [1, 2, 3]
p a[1] #=> 2
a[1] = 20
p a #=> [1, 20, 3]

# 存在しない要素を否定してもエラーにならずnilが返る
a = [1, 2, 3]
p a[4] #=> nil

# 元の大きさよりも大きい添字をすると、間の値がnilで埋められる
a[4] = 50
p a #=> [1, 2, 3, nil, 50]

# << を使うと配列の最後に要素を追加できる
a = []
a << 1
a << 2
a << 3
p a #=> [1, 2, 3]

# 配列の特定の位置にある要素を削除したい場合はdelete_atメソッドを使う
a.delete_at(1)
p a #=> [1, 3]

# 存在しない添え字を指定するとnilが返る
a.delete_at(100)
p a #=> [1, 3]

## 配列を使った変数への多重代入

# 多重代入
a, b = 1, 2
puts a #=> 1
puts b #=> 2

# 右辺に配列を使って多重代入
a, b = [1, 2]
puts a #=> 1
puts b #=> 2

# 右辺の数が少ない場合nilが入る
c, d = [10]
puts c #=> 10
puts d #=> nil

# 右辺の数が多い場合ははみだした値が切り捨てられる
e, f = [100, 200, 300]
p e #=> 100
p f #=> 200

# 多重代入で残りの全要素を配列として受け取ることもできる
# 左辺の変数に*をつけると、残りの全要素を配列として受け取ることができる
e, *f = [100, 200, 300]
p e #=> 100
p f #=> [200, 300]

# divmodメソッドは商と余りを配列で返す
p 14.divmod(3) #=> [4,2]

# 戻り値を配列のまま受け取る
quo_rem = 14.divmod(3)
puts "商=#{quo_rem[0]}, 余り=#{quo_rem[1]}" #=> 商=4, 余り=2

# 多重代入で別々の変数として受け取る
quotient, remainder = 14.divmod(3)
puts "商=#{quotient}, 余り=#{remainder}"
  #=> 商=4, 余り=2


## さまざまな要素の取得方法

# 添え字を2つ使うと添え字の位置と取得する長さを指定することができる
# 例) 2つ目の要素から3つ分の要素を取り出す
a = [1, 2, 3, 4, 5]
p a[1, 3] #=> [2, 3, 4]

# values_atを使うと、取得したい要素の添え字を複数指定できる
p a.values_at(0, 2, 4) #=> [1, 3, 5]

# [ 配列の長さ - 1 ] を指定すれば最後の要素が取得できる
p a[ a.size - 1 ] #=> 5

# Rubyでは添え字に負の値が使える
# -1 は最後の要素、 -2 は最後から2番目の要素
p a[-1] #=> 5
p a[-2] #=> 4
p a[-2,2] #=> [4, 5]

# lastメソッドで最後の要素が取得できる
# 引数に0以上の数字を渡すと、最後のn個が取得できる
p a.last #=> 5
p a.last(2) #=> [4, 5]

# firstメソッドでlastと反対の最初の要素を取得できる
p a.first #=> 1
p a.first(2) #=> [1, 2]

## さまざまな要素の変更方法
# 値を変更する場合も負の添え字が使える
# 注意: 正の値を使う場合と異なり、元の大きさを超えるような添え字を指定するとエラーになる
a = [1, 2, 3]
a[-3] = -10
p a #=> [-10, 2, 3]
# p a[-4] = 0 #=> index -4 too small for array; minimum: -3 (IndexError)

# 開始位置と長さを指定して要素を置き換えることもできる
# 2つ目からの3要素分を100で置き換える
a = [1, 2, 3, 4, 5]
a[1, 3] = 100
p a #=> [1, 100, 5]

# <<だけでなくpushメソッドを使っても要素を追加できる
# pushメソッドの場合は複数の値を追加できる
a = []
p a.push(1) #=> [1]
p a.push(2, 3) #=> [1, 2, 3]
# もし2, 3が配列だった場合、配列として追加される
a = []
b = [2, 3]
p a.push(1) #=> [1]
p a.push(b) #=> [1, [2, 3]]
# メソッドの引数に配列を渡す時、配列を展開して「複数の引数」として渡したい場合
# 配列の前に*を置く(splat展開)
a = []
b = [2, 3]
p a.push(1) #=> [1]
p a.push(*b) #=> [1, 2, 3]

# pushメソッドのように個数に制限のない引数のことを可変長引数という
# 自分で定義するメソッドで可変長引数を使いたい場合、引数名の手前に*をつける
#  def メソッド名(引数1, 引数2, *可変長引数)
#    メソッドの処理
#  end
# 可変長引数は配列として受け取る
# 例) 引数で渡された人命の全員に挨拶するメソッド
def greeting(*names)
  "#{names.join('と')}、こんにちは"
end
puts greeting('田中さん') #=> 田中さん、こんにちは
puts greeting('田中さん', '鈴木さん') #=> 田中さんと鈴木さん、こんにちは
puts greeting('田中さん', '鈴木さん', '佐藤さん') #=> 田中さんと鈴木さんと佐藤さん、こんにちは

# 指定した値に一致する要素を削除したい場合はdeleteメソッドを使う
# 値が2である要素を削除(削除した値が戻り値になる)
a = [1, 2, 3, 1, 2, 3]
p a.delete(2) #=> 2
p a #=> [1, 3, 1, 3]
# 存在しない値を指定するとnilが返却される
p a.delete(5) #=> nil
p a #=> [1, 3, 1, 3]

## 配列の連結
# 2つの配列を連結したい場合はconcatメソッドか、+演算子を使う
# concatメソッドは元の配列を変更する(破壊的)
a = [1]
b = [2, 3]
p a.concat(b)
p a #=> [1, 2, 3]  aは変更される(破壊的)
p b #=> [2, 3]  bは変更されない
# +演算子を使うと元の配列を変更せず、新しい配列を作成する
a = [1]
b = [2, 3]
p a + b #=> [1, 2, 3]
p a #=> [1]  aもbも変更されない
p b #=> [2, 3]

## 配列の和集合(|)、差集合(-)、積集合(&)
# Rubyの配列は和集合、差集合、積集合を求めることができる
# ｜ は和集合を求める演算子
# 2つの配列の要素を全て集め、重複しないようにして返す
a = [1, 2, 3]
b = [3, 4, 5]
p a | b #=> [1, 2, 3, 4, 5]
# - はさ集合を求める演算子
# 左の配列から右の配列に含まれる要素を取り除く
p a - b #=> [1, 2]
# & は積集合を求める演算子
# 2つの配列に共通する要素を返す
p a & b #=> [3]
# Rubyには配列よりも効率的に集合を扱えるSetクラスがある
# 本格的な集合演算をする場合は、配列よりもSetクラスの方が良い
require 'set'
a = Set.new([1, 2, 3])
b = Set.new([3, 4, 5])
p a | b #=> #<Set: {1, 2, 3, 4, 5}>
p a - b #=> #<Set: {1, 2}>
p a & b #=> #<Set: {3}>

## *で配列同士を非破壊的に連結する
# []の中に*付きで配列を置くと、配列が展開sれて別々の配列になる(splat展開の一種)
a = [1, 2, 3]
p [-1, 0, *a, 4, 5] #=> [-1, 0, 1, 2, 3, 4, 5]
# +を使ったイカと同じ意味となるが*を使った方が簡潔に書くことができる
p [-1, 0] + a + [4, 5] #=> [-1, 0, 1, 2, 3, 4, 5]

## ==で等しい配列かどうか判断する
p [1, 2, 3] == [1, 2, 3] #=> true
p [1, 2, 3] == [1, 2, 4] #=> false
p [1, 2, 3] == [1, 2] #=> false
p [1, 2, 3] == [1, 2, 3, 4] #=> false

## %記法で文字列の配列を簡潔に作成
# %記法ではカンマではなく空白文字(スペースや改行)が要素の区切り文字となる
# 文字列をシングルクウォートやダブルクオートで囲む必要がない
# 結果として[]を使う場合よりもコードが短くなる
# []で文字列の配列を作成する場合
p ['apple', 'melon', 'orange'] #=> ["apple", "melon", "orange"]
# %wで文字列の配列を作成する場合(!で囲む)
p %w!apple melon orange! #=> ["apple", "melon", "orange"]
# %Wで文字列の配列を作成する場合(丸カッコで囲む)
p %w(apple melon orange) #=> ["apple", "melon", "orange"]
# 空白文字(スペースや改行)が連続した場合も1つの区切りとみなされる
p %w(
  apple
  melon
  orange
  ) #=> ["apple", "melon", "orange"]
# 値にスペースを含めたい場合はバックスラッシュでエスケープする
p %w(big\ apple small\ melon orange) #=> ["big apple", "small melon", "orange"]
# 式展開や改行文字(\n)、タブ文字(\t)などを含めたい場合は%W(大文字W)を使う
prefix = 'This is'
p %W(#{prefix}\ an\ apple small\nmelon orange) #=> ["This is an apple", "small\nmelon", "orange"]

## 文字列を配列に変換する
# charsメソッドは文字列1文字1文字を配列の要素に分解するメソッド
p 'Ruby'.chars #=> ["R", "u", "b", "y"]
# splitメソッドは引数で渡した区切り文字で文字列を配列に分解するメソッド
p 'Ruby, Java, Perl, PHP'.split(',') #=> ["Ruby", " Java", " Perl", " PHP"]

## 配列に初期値を設定する
# []で配列を作るのも、Array.newを使って作るのも同じ
p [] == Array.new #=> true
# Array.newに引数を渡すと、その個数分の要素が追加される(初期値nil)
p Array.new(5) #=> [nil, nil, nil, nil, nil]
# さらに第2引数を指定するとnil以外の初期値を指定できる
p Array.new(5, 0) #=> [0, 0, 0, 0, 0]
# ブロックを使って初期値を設定することもできる
# ブロックは作成する要素の数だけ呼ばれ、ブロック引数には要素の添え字が渡される
# 配列にはブロックの戻り値がそれぞれ初期値として設定される
p Array.new(10) { |n| n % 3 + 1 } #=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]

## 配列に初期値を設定する場合の注意点
# 第2引数を使って初期値を設定する場合は要注意
# 例) 要素が5つで'default'を初期値とする配列を作成/1つ目の要素だけを大文字に変更
a = Array.new(5, 'default')
p a #=> ["default", "default", "default", "default", "default"]
# p a[0].object_id #=> 120
# p a[1].object_id #=> 120
# p a[2].object_id #=> 120
# p a[3].object_id #=> 120
# p a[4].object_id #=> 120
a[0].upcase!
p a #=> ["DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT"]
# 全て大文字に変わってしまう
# これは配列の全要素が同じオブジェクトを参照しているため発生する問題
# この問題を避けるためにはブロックで初期値を渡す
a = Array.new(5) {'default'}
p a #=> ["default", "default", "default", "default", "default"]
# p a[0].object_id #=> 140
# p a[1].object_id #=> 160
# p a[2].object_id #=> 180
# p a[3].object_id #=> 200
# p a[4].object_id #=> 220
a[0].upcase!
p a #=> ["DEFAULT", "default", "default", "default", "default"]
# ブロックを使うとブロックが呼ばれる度に文字列の'default'が新しく作成される
# 結果として配列の各要素は別々の文字列を参照している

## ミュータブル(変更可能)とイミュータブル(変更不可)
# ミュータブルなオブジェクトはブロックを使って初期値を設定した方が良い
# イミュータブルなオブジェクトは破壊的な変更が適用されない
# 例) Integer, Float, Symbol, True, False, Nil
p Array.new(5, 0) #=> [0, 0, 0, 0, 0]
